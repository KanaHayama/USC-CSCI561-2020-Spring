20200214
约3^25/4=2.11822E11种盘面，每个盘面要存两方的最优步数，存下来要上T，所以不可能放全部的表

考虑位运算。一共25个位置，每个位置3种情况，占2bit的话，全存下来要50bit，比int64小
需要先确认测试机long long是多少位的

可以通过编码检测对称减少搜索空间
有轴对称和旋转对称，偶尔有中心对称，以及这些的组合，分母是8

每一次落子XY占6位（全0为PASS），双方12位，可以塞到上面棋盘里
4字节记录一个情况，制作一个本机查表必胜的Agent是可能的
需要100+GB，SSD加内存完全可以全搜一遍

记得注意保存关键点
搜索时记录节点之间关系

先写CPU版，再写多线程，再SIMD，再CUDA

最后从终盘向上，每隔一段搜索深度记录一次最优值用作最后成品查表

傲腾加速？成本有点高啊

20200215
用深度优先的minimax搜索，搜索占用内存空间不多
现在的问题就是怎么存不同盘面的结果了
用原子操作而不加锁效果会好些
但所有数据又没法同时存在内存里，所以要么开虚拟内存，要么用某种编码将集中的操作聚集在一起，手动换入换出数据区

多个线程并行执行深搜，一个线程处理完自己的任务后，则？？？
如果遇到新的状态是其他线程处理过的，则不继续搜索，直接用已有数据。
如果遇到新的状态是其他线程正在处理的，则？？？

需要先建一张状态转移图，然后从结果倒着往前推
节点是棋盘状态，边是一方的动作，最多26种动作
根节点要单独加到队列中去，以便后续倒推
图要双向记录
但这个图太大了，不可能存得下

不仅是盘面，步数+盘面才是状态

既然存不下，那有没有可能完全倒着推状态
比如给定一个棋盘，上一个状态肯定是不管黑白去掉一个子，然后再分加上这个子会不会去掉其他棋子的2^n情况（n是封住的区域的个数）
粗算一下，这个方法至少要保证每秒能算100万种情况，那最快也要算10天，有一定困难

20200216
倒着搜不行，因为终盘的步数是不知道的

为了加速，深搜使用非递归形式

输出可行动作时不应该输出会直接导致自己输掉的动作（除了到最大步数的情况）
这是为了准确记录不同步骤到达同一状态的胜率

存储的内容是状态加对应的胜率

越往后面的步骤，可能存在的状态数越多，但对于给定一个状态，后续可能出现的状态越少

单线程搜索时，可以在每多少步子树拓展时记录一次胜率（黑白分别），以减少空间消耗，用的时候花一点时间搜一下就好了
但要确保不同顺序访问时，是否要记录状态的判断是一致的，比如使用固定第几步要记录，中间状态极多的步骤就不计了，现场算

但如何知道每一步有多少种状态，从而选出要记的步骤呢？可以先搜一遍，进行到每一步能有多少种状态，然后再决定，或者就估算一下

对称的状态，存状态值最小的
保存的数据结构使用map<UInt64,float>

20200224
如何并行化搜索？
使用多个深度优先搜索。
搜索时构建出一张有向图，遇到有其他线程正在搜索的子节点就记录并跳过去
